# ============
# Made By drewdrew0414
# ============

---

## 0. 목차
* ### 제1부: 물리적 기초와 정보 이론
 * #### 1.1 [랜다우어 한계](#11)
 * #### 1.2 [비가역 연산의 열역학](#12)
 * #### 1.3 [준-발리스틱 전송](#13)
 * #### 1.4 [양자 터널링 제어](#14)
 * #### 1.5 [확률적 컴퓨팅](#15)
 * #### 1.6 [열잡음과 SNR](#16)



* ### 제2부: 나노 소재와 트랜지스터 구조
 * FinFET의 물리적 임계점: 3면 게이트의 전하 통제력 상실 분석.
 * GAA(Gate-All-Around): 채널 4면을 감싸는 나노시트 기술.
 * MBCFET 아키텍처: 나노시트 폭 조절을 통한 전류 구동력 최적화.
 * High-k 메탈 게이트: 유전율 최적화를 통한 누설 전류 차단 기술.
 * BSPD(후면 전력 공급): 전력망을 다이 뒷면으로 배치하는 배선 혁명.
 * CFET(Complementary FET): n형/p형 수직 적층을 통한 실장 면적 극대화.
제3부: 회로 설계와 전력 무결성
 * DVFS 메커니즘: 작업 부하에 따른 전압-클럭 실시간 매핑 알고리즘.
 * IR Drop 및 전압 강하: 배선 저항으로 인한 타이밍 지연 보정 기술.
 * 클럭 트리 합성(CTS): 수십억 개 소자의 동기화를 위한 H-Tree 구조.
 * Clock Skew 관리: 초고클럭 환경에서 신호 도달 시간 편차 제어.
 * Dark Silicon 전략: 전력 밀도 한계로 인한 유휴 영역 배치 최적화.
 * 전력 게이팅: 누설 전류 방지를 위한 블록별 물리적 전원 차단.
제4부: 프론트엔드 - 명령어 오케스트레이션
 * TAGE 분기 예측기: 기하학적 이력 기반 예측 알고리즘 심층 분석.
 * 명령어 프리패치: 메모리 지연을 은폐하기 위한 선제적 로드.
 * uOps 캐시 관리: x86 명령어를 고정 길이 내부 명령어로 변환/저장.
 * 마이크로코드 엔진: 복잡한 명령어 처리를 위한 내부 ROM 실행 계층.
 * RAT(Register Alias Table): 논리-물리 레지스터 매핑 및 리네이밍.
 * 디코드 파이프라인: 명령어 병렬 해석을 위한 멀티 디코더 설계.
제5부: 백엔드 - 실행 엔진과 스케줄링
 * ROB(Reorder Buffer): 비순차 실행 결과의 순차적 확정(Commit) 메커니즘.
 * 예약 스테이션(RS): 데이터 준비 시까지 명령어를 보관하는 대기열.
 * 슈퍼스칼라 이슈: 클럭당 실행 유닛으로 투입되는 명령어 폭 결정.
 * 실행 포트 최적화: ALU, FPU, SIMD 유닛 간의 데이터 경로 배분.
 * 메모리 이사(Disambiguation): 투기적 로드/스토어의 주소 충돌 감지.
 * 포트 충돌 해소: 공유 자원을 사용하는 명령어 간의 스케줄링 우선순위.
제6부: 메모리 계층 및 일관성
 * 캐시 계층 최적화: L1/L2/L3 캐시의 용량과 지연 시간 트레이드오프.
 * 지능형 캐시 축출: 신경망 기반의 캐시 교체 알고리즘(Replacement Policy).
 * MESI/MOESI 프로토콜: 멀티 코어 간 데이터 무결성 보장 모델.
 * TLB 가속 구조: 가상-물리 주소 변환을 위한 다단계 하드웨어 캐시.
 * Prefetcher 알고리즘: 데이터 접근 패턴 학습을 통한 선제적 로드.
 * 메모리 컨트롤러 설계: DDR5/HBM3와의 초고속 인터페이스 정밀 제어.
제7부: AI 및 이종 가속
 * NPU 시스톨릭 어레이: 대규모 행렬 연산을 위한 전용 하드웨어 구조.
 * AMX(Matrix Extensions): CPU 코어 내 직접 통합된 행렬 연산 유닛.
 * 저정밀도 산술(FP8/INT4): AI 추론 효율을 위한 데이터 규격 최적화.
 * GPGPU 인터커넥트: NVLink/Infinity Fabric을 통한 메모리 통합.
 * 컴퓨팅 인 메모리(PIM): 데이터 이동 없이 메모리 내부에서 연산 수행.
 * Tensor Core 아키텍처: AI 가속을 위한 전용 연산 로직의 고도화.
제8부: 패키징 및 인터커넥트
 * 칩렛(Chiplet) 분할: 기능별 최적 공정 적용을 통한 수율 혁신.
 * CoWoS 및 Foveros: 2.5D/3D 적층을 통한 이종 칩 통합 패키징.
 * UCIe 표준: 칩렛 간 통신을 위한 업계 표준 물리 계층 인터페이스.
 * CXL 3.0 프로토콜: 메모리 풀링 및 장치 간 캐시 일관성 유지.
 * 광(Optical) I/O: 전기를 빛으로 변환하여 데이터 전송 전력 극복.
 * 하이브리드 본딩: 칩 간 연결 밀도를 극대화하는 범프리스 본딩 기술.
제9부: 시스템 소프트웨어와 보안
 * Thread Director: 하이브리드 코어 간 작업 배분 OS-HW 협력.
 * 부채널 공격 방어: 투기적 실행 취약점(Spectre 등) 하드웨어적 보완.
 * TEE(신뢰 실행 환경): 하드웨어 격리 기반 데이터 암호화 영역.
 * 온칩 Telemetry: 온도/전압/노화도 실시간 감시 센서 네트워크.
 * 가상화 가속(VT-x/AMD-V): VM 실행 성능을 위한 하드웨어 지원.
 * 하드웨어 보안 모듈(HSM): 암호화 키 관리 및 무결성 검증 전용 로직.
제10부: 미래 컴퓨팅 패러다임
 * 액침 냉각(Immersion Cooling): 데이터센터급 열 소산을 위한 냉각 기술.
 * 뉴로모픽 아키텍처: 인간 뇌를 모방한 비동기식 연산 소자.
 * 양자-고전 하이브리드: CPU 컨트롤러와 QPU 가속기의 통합 구조.
 * 탄소 나노튜브(CNT): 실리콘 대체 초고효율 차세대 소재 연구.
 * 자가 치유 실리콘: 회로 결함을 스스로 우회하는 논리 구조.
 * 지구 규모 리소스 풀링: 전 세계 CPU 자원을 CXL로 묶는 인프라.
[최종 동작 메커니즘: 데이터의 탄생에서 소멸까지]
CPU의 최종 동작은 **"전기적 신호의 흐름"**과 **"논리적 상태의 전이"**가 만나는 지점입니다.
 * 입력 및 스케줄링: 사용자가 명령을 내리면 OS 스케줄러가 이를 인지하고, CPU 내 Thread Director가 가장 적합한 코어(P-코어 또는 E-코어)를 선정합니다.
 * 전력 공급 및 활성화: **VRM(전압 조절 모듈)**에서 변환된 전력이 **BSPD(후면 전력망)**를 통해 각 트랜지스터에 도달합니다.
 * 명령어 처리 파이프라인:
   * Frontend: 명령어를 가져와 uOps로 쪼개고 분기를 예측합니다.
   * Execution: 비순차 실행 엔진이 ALU/FPU를 가동하여 연산합니다.
   * Backend: 연산 결과를 레지스터에 기록하고 ROB를 통해 최종 확정(Retire)합니다.
 * 메모리 액세스 및 캐시 미스: 필요한 데이터가 캐시에 없으면 CXL 인터페이스나 HBM을 통해 외부 메모리로 고속 이동합니다.
 * 결과 출력 및 열 배출: 최종 데이터가 저장 장치로 전송됨과 동시에, 연산 과정에서 발생한 열은 히트 스프레더와 액체 냉각 시스템을 통해 외부로 방출됩니다.
[알면 좋은 엔지니어급 상식 (Deep Knowledge)]
 * 수율(Yield)과 칩렛의 경제학: 칩이 커질수록 불량 확률이 기하급수적으로 높습니다. 그래서 AMD는 칩을 쪼개는 칩렛 방식을 선택해 가격 경쟁력을 확보했습니다.
 * 성능의 3요소 (CPI, Clock, Instruction Count): 프로그램의 전체 실행 시간은 (명령어 개수 × CPI × 클럭 주기)로 결정됩니다. 클럭만 높인다고 장땡이 아닌 이유가 여기에 있습니다.
 * 메모리 벽(Memory Wall): CPU는 초당 수조 번 연산하지만, RAM은 그 속도를 못 따라옵니다. 그래서 CPU 면적의 절반 이상이 계산기가 아닌 **'캐시 메모리'**로 채워져 있습니다.
 * 투기적 실행의 양날의 검: 분기 예측을 통해 성능을 2배 이상 올렸지만, 이 과정에서 발생하는 데이터 흔적을 노린 것이 바로 '멜트다운/스펙터' 보안 취약점입니다.
 * 에너지 효율(Performance per Watt): 2026년 현재 가장 중요한 지표입니다. 단순히 빠른 CPU보다, 와트당 성능이 높은 CPU가 서버 시장과 모바일 시장을 지배합니다.







---

<a id=11></a>
#### 1.1 랜다우어 한계
IBM의 연구원 "롤프 랜다우어"가 제안한 물리법칙이다.
요약 : **"정보를 지우는 행위는 반드시 열(에너지)을 발생시킨다"**

* 물리적 정의와 공식
  * 컴퓨터가 데이터(0과 1)을/를 지울 때 발생하는 최소한의 열 에너지는 공식으로 아래와 같이 적용한다.
  * $E = k_{B} Tln2$
    * $​k_B$ (볼츠만 상수): 입자의 미시적인 에너지를 결정하는 상수이다.
    * $​T$ (절대 온도): 주변 환경의 온도입니다. 온도가 높을수록 지울 때 필요한 에너지가 커진다.
    * ​$ln2$ (2의 자연로그): 정보가 2가지 상태(0, 1)에서 1가지 상태로 줄어드는 비율을 의미한다.

 * **상온(약 25°C)에서 **1비트를 지우려면 약 2.85 × $10^{-21}$ 줄(J) 이라는 극미량의 에너지가 반드시 열로 방출**되어야 한다. 이는 기술이 아무리 발전해도 넘을 수 없는 물리적 마지노선이다.

* 비유
  * 종이에 0과 1을 그린 후 지우개로 지울 때 지우개 일 때만 열이 생긴다. (열역학 제2법칙: 엔트로피 증가의 법칙과 연결됨)

[ TMI ]
* KAIST 연구팀, 차세대 소자 개발의 핵심 '물리 표준이론' 대안 제시 [(보러가기)](https://www.kaist.ac.kr/news/html/news/?mode=V&mng_no=9010) [자료내용 요약본 보러가기](CPU/thesis/ㅂ
  
  * KAIST 전기및전자공학부 김용훈 교수 연구팀이 낸 논문에 따르면 차세대 반도체 소자 설계의 기반이 되는 **물리학 표준이론의 대안**을 제시하고, 이를 소프트웨어로 구현하는 데 성공했다는 내용이 있다.
    
  * 기존의 표준이론(양자수송 이론)은 반도체 소자의 전도성(전류가 흐르는 성질)은 해석할 수 있었지만, 소자 전체의 '에너지'를 정확히 계산하는 데 한계가 있었다.
    
  * ​김용훈 교수 연구팀은 이 한계를 극복하여 소자의 에너지 특성까지 정확하게 예측할 수 있는 새로운 이론을 정립했다.

---
    
<a id=12></a>
#### 1.2 비가역 연산의 열역학
연산에서 '비가역적'이라는 말은 결과값을 보고 입력값을 되돌릴 수 없다는 뜻입니다.

* 정보의 비가역성 (Logical Irreversibility)
  * ​가역 연산 (Reversible): 입력과 출력이 1:1 대응입니다. 예를 들어 'NOT 게이트'는 출력이 0이면 입력이 1이었음을 확실히 알 수 있습니다.
  * ​비가역 연산 (Irreversible): 입력값이 소실됩니다. 'AND 게이트'에서 출력이 0일 때, 입력이 (0,0), (0,1), (1,0) 중 무엇이었는지 알 수 없습니다. 이 과정에서 정보의 확실성이 파괴됩니다.

 * 열역학 제2법칙과의 연결 (엔트로피)
   * ​열역학 제2법칙에 따르면 고립된 시스템의 전체 엔트로피(무질서도)는 감소할 수 없습니다.
   * ​정보 엔트로피: 정보를 안다는 것은 상태가 정해져 있다는 것(낮은 엔트로피)을 의미합니다.
   * ​정보 삭제와 엔트로피: 비가역 연산으로 정보를 지우면 시스템 내부의 정보 엔트로피가 감소합니다(상태가 0으로 강제 통일됨).
   * ​열의 방출: 시스템 내부의 엔트로피가 줄어들었으므로, 우주 전체의 엔트로피 평형을 맞추기 위해 그 감소분만큼의 엔트로피를 **열(Heat)**의 형태로 외부로 반드시 내보내야 합니다.
  
[ TMI ]
* **롤프 랜다우어**는 이 열역학적 비용을 수식으로 정리했다, 이것이 [랜다우어 한계](#11) 이다.

* 현재 우리가 사용하는 대부분의 CPU는 비가역 연산 방식을 채택하고 있습니다.
  * 열 장벽: 공정이 미세화될수록 단위 면적당 처리하는 비트 수가 많아지며, 비가역 연산으로 인한 발열 밀도가 높아집니다.
  * ​가역 컴퓨팅의 필요성: 랜다우어 한계를 극복하기 위해, 정보를 지우지 않고 연산 과정을 논리적으로 되돌릴 수 있는 '가역 회로' 설계가 미래 컴퓨팅의 대안으로 연구되고 있습니다.

---

<a id=13></a>
#### 1.3 준-발리스틱 전송
전자가 반도체 내를 이동할 때, 산란(충돌) 현상이 완전히 없지는 않지만 매우 드물게 발생하는 전송 상태를 의미합니다.
소자의 크기가 나노미터(nm) 단위로 작아지면서 현대 반도체 공학에서 매우 중요하게 다뤄지는 개념입니다.

---

<a id=14></a>
#### 1.4 양자 터널링 제어
나노 단위의 양자에서 일어나는 현상을 우리가 원하는 대로 조절하는 기술을 말한다.

* 원래 고전 역학으로는 공을 던졌을 때 벽보다 높게 던지지 않으면 벽을 넘을 수 없다.
  
* 하지만 원자만큼 작은 양자의 세계에서는 입자가 파동의 성질을 가지고 있어서, 에너지가 부족해도 마치 유령처럼 벽을 뚫고 반대편으로 나타나는 현상이 발생한다, 이것을 '터널을 뚫고 지나가는 것 같다'고 해서 양자 터널링이라고 부른다.

* 제어해야하는 이유?
  * 반도체가 점점 작아지면서 문제가 생겼기 때문이다.
  * 
  * ​문제점:
    * 반도체 안의 길(회로)이 너무 얇아지니까, 전기가 흐르지 말아야 할 곳에서도 전자가 터널링 현상으로 벽을 뚫고 막 지나가 버린다. 이걸 **누설 전류**라고 하는데, 이는 컴퓨터가 뜨거워지고 배터리가 빨리 닳는 원인이 된다.
      
  * 그래서 이 터널링 현상을 못 일어나게 꽉 막거나, 혹은 원할 때만 딱 일어나게 조절하는 기술이 필요해진 것이다.
 
 * 제어법:
   * 1. **장벽의 두께 조절 (두껍게 만들기)**
   - 터널링은 벽이 얇을수록 잘 일어난다. 
   ➡️ 전자가 못 넘어가게 아주 정밀한 신소재를 사용해서 벽의 두께를 원자 몇 개 층 단위로 조절한다.

   * 2. **전압(전기적 힘)으로 조절**
   - 외부에서 전기를 걸어주면 전자가 느끼는 벽의 높이나 모양이 변하게 된다.
   ➡️ 전압을 높여서 전자가 터널링을 더 잘하게 유도하거나, 반대로 꽉 막을 수 있게 된다.

   * 3. **신소재 활용 (2차원 물질)**
   - '그래핀' 같은 아주 얇은 물질을 겹겹이 쌓아서 전자가 지나가는 길을 아주 미세하게 컨트롤 할 수 있다.
   ➡️ 최근 KAIST 연구팀이 발표하는 성과들도 이런 새로운 물질로 터널링을 정밀하게 조절하는 소프트웨어나 소자에 대한 내용이 많다. [참고자료](https://news.kaist.ac.kr/news/html/news/?mode=V&mng_no=19590)

---


